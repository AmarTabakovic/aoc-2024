#include "util.hpp"

using NumType = unsigned long long;
using MemoizationCache = std::map<std::pair<NumType, NumType>, NumType>;

int NumDigits(NumType n)
{
  int count{0};
  while (n > 0) {
    n /= 10;
    count++;
  }
  return count;
}

bool EvenNumberOfDigits(NumType n)
{
  return NumDigits(n) % 2 == 0;
}

std::pair<NumType, NumType> SplitNumber(NumType n)
{
  auto m{static_cast<NumType>(std::pow(10, NumDigits(n) / 2))};
  return {n / m, n % m};
}

NumType Solve(const std::vector<std::string> &input, int num_iterations)
{
  std::vector<NumType> stones{};

  NumType stone{0};
  const auto input_line{input[0]};
  std::istringstream iss{input_line};
  while (iss >> stone) {
    stones.push_back(stone);
  }

  // Memoize the number of stones generated by each stone at each recursion depth
  MemoizationCache memo{};
  std::function<NumType(NumType, NumType)> blink = [&blink, &memo](NumType stone,
                                                                   NumType depth) -> NumType {
    if (depth == 0) {
      return 1;
    }

    const std::pair<NumType, NumType> sd{stone, depth};

    if (memo.contains(sd)) {
      return memo[sd];
    }

    if (stone == 0) {
      memo[sd] = blink(1, depth - 1);
      return memo[sd];
    } else if (EvenNumberOfDigits(stone)) {
      const auto [l, r] = SplitNumber(stone);
      memo[sd] = blink(l, depth - 1) + blink(r, depth - 1);
      return memo[sd];
    } else {
      memo[sd] = blink(stone * 2024, depth - 1);
      return memo[sd];
    }
  };

  NumType num_stones{0};
  for (auto stone : stones) {
    num_stones += blink(stone, num_iterations);
  }

  return num_stones;
}

NumType Part1(const std::vector<std::string> &input)
{
  return Solve(input, 25);
}

NumType Part2(const std::vector<std::string> &input)
{
  return Solve(input, 75);
}

int main() {
  std::ios::sync_with_stdio(false);

  std::vector<std::string> input = util::ReadInput("input");

  std::cout << Part1(input) << std::endl;
  std::cout << Part2(input) << std::endl;

  return 0;
}
